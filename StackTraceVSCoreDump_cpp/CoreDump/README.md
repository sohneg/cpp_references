## Compilation

Compile the example program with debugging information:

```bash
g++ -g -o CoreDump CoreDump.cpp
```

This command uses the GNU Compiler (g++) to compile the `CoreDump.cpp` source code into an executable named `CoreDump.exe`. The `-g` flag includes debugging information in the executable, which is essential for effective debugging with GDB.

Ensure that you have the necessary build tools installed on your system. If you encounter any compilation errors, check that your C++ compiler is properly configured.

## Running the Program

Run the compiled program and generate a core dump:

```bash
ulimit -c unlimited
./CoreDump
```

This will create a core dump file in the specified directory.

`ulimit -c unlimited`:

- `ulimit` is a shell command that sets or displays user-level resource limits.
- `-c` specifies the core dump size, which determines the maximum size of core dump files.
unlimited sets the core dump size to `unlimited`, meaning that the program is allowed to generate core dump files of any size.
In simpler terms, this command ensures that the program can generate core dump files without any size restrictions.


### Get core dump file location

Determine the location where core dumps are generated. By default, core dumps are often generated in the same directory where the executable is located. You can use the core_pattern to check the default location:

```bash
cat /proc/sys/kernel/core_pattern
```

## Debugging with GDB

Follow the steps mentioned in the "Debugging with GDB" section to analyze the core dump using GDB. Ensure you replace `/path/to/core/dump/file` with the actual path and filename of your core dump file. For each time you running the executable it will generate a new dump file. Check the folder which one is the correct one.

```bash
gdb ./CoreDump /path/to/core/dump/file
```

## Analyzing the Core Dump

In GDB, use the `bt` (backtrace) command to view the call stack:

```bash
bt
```

This will display the stack trace, showing the functions called at the time of the crash. Analyzing the stack trace can help identify the source of the segmentation fault.

```bash
Reading symbols from ./CoreDump.exe...
[New LWP 43504]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./CoreDump'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000055b32cebe17d in funcC () at CoreDump.cpp:5
5         *ptr = 42;
(gdb) bt
#0  0x000055b32cebe17d in funcC () at CoreDump.cpp:5
#1  0x000055b32cebe193 in funcB () at CoreDump.cpp:8
#2  0x000055b32cebe1a3 in funcA () at CoreDump.cpp:10
#3  0x000055b32cebe1b3 in main () at CoreDump.cpp:13
(gdb)
```

---

